<?xml version="1.0" encoding="utf-16"?>
<CLAS CLSNAME="ZSAPLINK_CLASS" VERSION="1" LANGU="E" DESCRIPT="SapLink Class Installer" UUID="4558408635A702C600000000A7E42BB6" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" AUTHOR="DEVELOPER" CREATEDON="20101125" CHANGEDBY="DEVELOPER" CHANGEDON="20101127" CHGDANYON="00000000" CLSCCINCL="X" FIXPT="X" UNICODE="X" R3RELEASE="702" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " REFCLSNAME="ZSAPLINK">
 <publicSection>class ZSAPLINK_CLASS definition
  public
  inheriting from ZSAPLINK
  create public .

*&quot;* public components of class ZSAPLINK_CLASS
*&quot;* do not include other source files here!!!
public section.
  type-pools ABAP .
  type-pools SEOP .
  type-pools SEOR .
  type-pools SEOS .
  type-pools SEOT .
  type-pools SEOX .

  methods CHECKEXISTS
    redefinition .
  methods CREATEIXMLDOCFROMOBJECT
    redefinition .
  methods CREATEOBJECTFROMIXMLDOC
    redefinition .</publicSection>
 <protectedSection>*&quot;* protected components of class ZSAPLINK_CLASS
*&quot;* do not include other source files here!!!
protected section.

  methods DELETEOBJECT
    redefinition .
  methods GETOBJECTTYPE
    redefinition .</protectedSection>
 <privateSection>private section.
*&quot;* private components of class ZSAPLINK_CLASS
*&quot;* do not include other source files here!!!

  methods CREATE_TEXTPOOL
    importing
      !TEXTPOOLNODE type ref to IF_IXML_ELEMENT .
  methods FINDIMPLEMENTINGCLASS
    importing
      !METHODNAME type STRING
      !STARTCLASS type STRING optional
    returning
      value(CLASSNAME) type STRING .
  methods GET_TEXTPOOL
    returning
      value(TEXTNODE) type ref to IF_IXML_ELEMENT .
  methods CREATE_DOCUMENTATION
    importing
      !DOCNODE type ref to IF_IXML_ELEMENT .
  methods GET_DOCUMENTATION
    returning
      value(DOCNODE) type ref to IF_IXML_ELEMENT .
  methods GET_METHOD_DOCUMENTATION
    importing
      !METHOD_KEY type SEOCPDKEY
    returning
      value(DOCNODE) type ref to IF_IXML_ELEMENT .
  methods CREATE_METHOD_DOCUMENTATION
    importing
      !METHDOCNODE type ref to IF_IXML_ELEMENT .</privateSection>
 <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
 <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
 <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
 <textPool/>
 <classDocumentation/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="SEOP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="SEOR" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="SEOS" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="SEOT" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <typeUsage CLSNAME="ZSAPLINK_CLASS" TYPEGROUP="SEOX" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <forwardDeclaration>ABAP</forwardDeclaration>
 <forwardDeclaration>SEOP</forwardDeclaration>
 <forwardDeclaration>SEOR</forwardDeclaration>
 <forwardDeclaration>SEOS</forwardDeclaration>
 <forwardDeclaration>SEOT</forwardDeclaration>
 <forwardDeclaration>SEOX</forwardDeclaration>
 <inheritance CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" STATE="1" AUTHOR="DEVELOPER" CREATEDON="20101125" CHANGEDBY="DEVELOPER" CHANGEDON="20101127">
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="CHECKEXISTS" EXPOSURE="2"/>
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="CREATEIXMLDOCFROMOBJECT" EXPOSURE="2"/>
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="CREATEOBJECTFROMIXMLDOC" EXPOSURE="2"/>
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="DELETEOBJECT" EXPOSURE="1"/>
  <redefinition CLSNAME="ZSAPLINK_CLASS" REFCLSNAME="ZSAPLINK" VERSION="1" MTDNAME="GETOBJECTTYPE" EXPOSURE="1"/>
 </inheritance>
 <method CLSNAME="ZSAPLINK" CMPNAME="CHECKEXISTS" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method CHECKEXISTS.
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

data classkey type SEOCLSKEY.
data not_active TYPE  SEOX_BOOLEAN.

  classKey-clsName = objname.

  call function &apos;SEO_CLASS_EXISTENCE_CHECK&apos;
    EXPORTING
      clskey        = classkey
    IMPORTING
      not_active    = not_active
    EXCEPTIONS
*      not_specified = 1
      not_existing  = 2.
*      is_interface  = 3
*      no_text       = 4
*      inconsistent  = 5
*      others        = 6.

  if sy-subrc &lt;&gt; 2.
    exists = &apos;X&apos;.
  endif.
endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK" CMPNAME="CREATEIXMLDOCFROMOBJECT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method CREATEIXMLDOCFROMOBJECT.
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/


  DATA publicsection TYPE REF TO if_ixml_element.
  DATA protectedsection TYPE REF TO if_ixml_element.
  DATA privatesection TYPE REF TO if_ixml_element.
  DATA localimplementation TYPE REF TO if_ixml_element.
  DATA localtypes TYPE REF TO if_ixml_element.
  DATA localmacros TYPE REF TO if_ixml_element.
  data textPoolNode type ref to if_ixml_element.
  data docuNode type ref to if_ixml_element.
  data methodDocuNode  type ref to if_ixml_element.
  DATA rootnode TYPE REF TO if_ixml_element.
  DATA reportlist TYPE STANDARD TABLE OF string.
  DATA includename TYPE program.
  DATA _classname TYPE seoclsname.
  DATA reportstring TYPE string.
  DATA rc TYPE sysubrc.
  DATA classdescr TYPE REF TO cl_abap_classdescr.
  DATA typedescr TYPE REF TO cl_abap_typedescr.
  DATA methoddescr TYPE abap_methdescr.
  DATA methodnode TYPE REF TO if_ixml_element.
  DATA parameternode TYPE REF TO if_ixml_element.
  DATA sourcenode TYPE REF TO if_ixml_element.
  DATA exceptionnode TYPE REF TO if_ixml_element.
  DATA exceptionlist TYPE seos_exceptions_r.
  DATA anexception TYPE vseoexcep.
  data inheritanceNode type ref to if_ixml_element.
  data redefNode type ref to if_ixml_element.

  DATA tempstring TYPE string.
  DATA methodkey TYPE seocpdkey.
  DATA clsmethkey TYPE seocmpkey.
  DATA methodproperties TYPE vseomethod.
  DATA classkey TYPE seoclskey.
  DATA classproperties TYPE vseoclass.
  DATA paramdescr TYPE abap_parmdescr.
  DATA paramkey TYPE seoscokey.
  DATA paramproperties TYPE vseoparam.
  DATA superclass TYPE REF TO cl_abap_typedescr.
  DATA superclassname TYPE string.
  DATA superclasskey TYPE seorelkey.

  DATA attribdescr TYPE abap_attrdescr.
  DATA attribkey TYPE seocmpkey.
  DATA attribproperties TYPE vseoattrib.
  DATA attribnode TYPE REF TO if_ixml_element.
  DATA inheritanceprops TYPE vseoextend.
  DATA redefines TYPE STANDARD TABLE OF seoredef
      WITH KEY clsname refclsname version mtdname.
  DATA inheritance TYPE SEOR_INHERITANCE_R.
  DATA redefinitions TYPE seor_redefinitions_r.
  data redefinition like line of redefinitions.
  DATA forwarddeclarationlist TYPE seot_typepusages_r.
  DATA forwarddeclaration TYPE REF TO if_ixml_element.
  DATA forwarddeclarationrow TYPE seot_typepusage_r.

  DATA otrnode TYPE REF TO if_ixml_element.
  DATA _otrguid TYPE sotr_conc.

  _classname = objname.
  classkey-clsname = objname.

*  setObjectType( ).

  DATA _objtype TYPE string.
*  _objType = objType.
  _objtype = getobjecttype( ).
  rootnode = xmldoc-&gt;create_element( _objtype ).
  CALL FUNCTION &apos;SEO_CLASS_GET&apos;
    EXPORTING
      clskey       = classkey
      version      = &apos;1&apos;
    IMPORTING
      class        = classproperties
    EXCEPTIONS
      not_existing = 1
      deleted      = 2
      is_interface = 3
      model_only   = 4.

  IF sy-subrc &lt;&gt; 0.
    CASE sy-subrc.
      WHEN 1.
        RAISE EXCEPTION TYPE zcx_saplink
          EXPORTING
            textid = zcx_saplink=&gt;not_found
            object = objname.
      WHEN 2.
        RAISE EXCEPTION TYPE zcx_saplink
          EXPORTING
            textid = zcx_saplink=&gt;error_message
            msg    = &apos;class deleted&apos;.
      WHEN 3.
        RAISE EXCEPTION TYPE zcx_saplink
          EXPORTING
            textid = zcx_saplink=&gt;error_message
            msg    = &apos;interfaces not supported&apos;.
      WHEN 4.
        RAISE EXCEPTION TYPE zcx_saplink
          EXPORTING
            textid = zcx_saplink=&gt;error_message
            msg    = &apos;class is modeled only&apos;.
    ENDCASE.
  ENDIF.

  setattributesfromstructure( node = rootnode structure =
  classproperties ).
  TRY.
      CALL METHOD cl_abap_classdescr=&gt;describe_by_name
        EXPORTING
          p_name         = objname
        RECEIVING
          p_descr_ref    = typedescr
        EXCEPTIONS
          type_not_found = 1.
      IF sy-subrc = 0.
        classdescr ?= typedescr.
      ELSE.

      ENDIF.
    CATCH cx_root.
      RAISE EXCEPTION TYPE zcx_saplink
        EXPORTING
          textid = zcx_saplink=&gt;system_error.
  ENDTRY.

  CALL METHOD classdescr-&gt;get_super_class_type
    RECEIVING
      p_descr_ref           = superclass
    EXCEPTIONS
      super_class_not_found = 1.

  IF sy-subrc = 0.
    superclassname = superclass-&gt;get_relative_name( ).
    IF NOT superclassname CS &apos;OBJECT&apos;.
      superclasskey-clsname = objname.
      superclasskey-refclsname = superclassname.
      CALL FUNCTION &apos;SEO_INHERITANC_GET&apos;
        EXPORTING
          inhkey        = superclasskey
        IMPORTING
          inheritance   = inheritanceprops
          redefinitions = redefines.
      setattributesfromstructure( node = rootnode structure =
      inheritanceprops ).
    ENDIF.
  ENDIF.

*/***TPJ - Added Logic for TYPES  -------------------*/
  DATA: types      TYPE seoo_types_r,
        wa_type    LIKE LINE OF types,
        types_node TYPE REF TO if_ixml_element.
  CALL FUNCTION &apos;SEO_TYPE_READ_ALL&apos;
    EXPORTING
      cifkey            = classkey
      version           = 1
    IMPORTING
      types             = types
    EXCEPTIONS
      clif_not_existing = 1
      OTHERS            = 2.
  IF sy-subrc &lt;&gt; 0.
  ENDIF.
  LOOP AT types INTO wa_type.
    types_node = xmldoc-&gt;create_element( &apos;types&apos; ).
    setattributesfromstructure( node = types_node structure =
    wa_type ).
    rc = rootnode-&gt;append_child( types_node ).
  ENDLOOP.
*/***TPJ - End of Added Logic for TYPES  -------------------*/

*/***TPJ - Added Logic for Friends  -------------------*/
  DATA: clif_keys     TYPE STANDARD TABLE OF seoclskey,
        friends       TYPE STANDARD TABLE OF seofriends,
        wa_friend     LIKE LINE OF friends,
        friends_node  TYPE REF TO if_ixml_element.

  APPEND classkey TO clif_keys.
  CALL FUNCTION &apos;SEO_FRIENDS_SELECT&apos;
    EXPORTING
      WITH_EXTERNAL_REF = &apos;X&apos;
    TABLES
      clif_keys         = clif_keys
      friends_relations = friends.
  IF sy-subrc &lt;&gt; 0.
  ENDIF.
  LOOP AT friends INTO wa_friend.
    friends_node = xmldoc-&gt;create_element( &apos;friends&apos; ).
    setattributesfromstructure( node = friends_node structure =
    wa_friend ).
    rc = rootnode-&gt;append_child( friends_node ).
  ENDLOOP.
*/***TPJ - End of Added Logic for Friends  -------------------*/

*/***ewH - Added Logic for Interfaces  -------------------*/
  DATA: it_implementings type seor_implementings_r,
        wa_implementings like line OF it_implementings,
        implementingNode TYPE REF TO if_ixml_element.

  CALL FUNCTION &apos;SEO_IMPLEMENTG_READ_ALL&apos;
    EXPORTING
      CLSKEY             = classkey
    IMPORTING
      IMPLEMENTINGS      = it_implementings
    EXCEPTIONS
      CLASS_NOT_EXISTING = 1
      OTHERS             = 2.

  LOOP AT it_implementings INTO wa_implementings.
    implementingNode = xmldoc-&gt;create_element( &apos;implementing&apos; ).
    setattributesfromstructure( node = implementingNode structure =
    wa_implementings ).
    rc = rootnode-&gt;append_child( implementingNode ).
  ENDLOOP.
*/***ewH - End of Added Logic for Interfaces  -------------------*/
*/***rrq - Added Logic for EVENTS  -------------------*/
  DATA: events      TYPE SEOO_EVENTS_R,
        wa_event    LIKE LINE OF events,
        event_node  TYPE REF TO if_ixml_element,
        eventkey    type SEOCMPKEY,
        eventparams type seos_parameters_r,
        wa_params   type seos_parameter_r.
  CALL FUNCTION &apos;SEO_EVENT_READ_ALL&apos;
    EXPORTING
      cifkey            = classkey
      version           = 1
    IMPORTING
      events            = events
    EXCEPTIONS
      clif_not_existing = 1
      OTHERS            = 2.
  IF sy-subrc &lt;&gt; 0.
  ENDIF.
  LOOP AT events INTO wa_event.
    eventkey-clsname = wa_event-clsname.
    eventkey-cmpname = wa_event-CMPNAME.
    event_node = xmldoc-&gt;create_element( &apos;events&apos; ).
    setattributesfromstructure( node = event_node structure =
    wa_event ).
    CALL FUNCTION &apos;SEO_EVENT_SIGNATURE_GET&apos;
      EXPORTING
        EVTKEY     = eventkey
      IMPORTING
        PARAMETERS = eventparams.

*   parameters
    loop at eventParams into wa_params.

      parameternode = xmldoc-&gt;create_element( &apos;parameter&apos; ).
      setattributesfromstructure( node = parameternode
      structure = wa_params ).
      rc = event_node-&gt;append_child( parameternode ).
    ENDLOOP.
    rc = rootnode-&gt;append_child( event_node ).
  ENDLOOP.
*/***rrq - End of Added Logic for EVENTS  -------------------*/

*/--------------------------------------------------------------------\
*|                                                                    |
  includename = cl_oo_classname_service=&gt;get_pubsec_name( _classname ).
  READ REPORT includename INTO reportlist.
  publicsection = xmldoc-&gt;create_element( &apos;publicSection&apos; ).

  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = publicsection-&gt;if_ixml_node~set_value( reportstring ).
  CLEAR reportstring.
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_prosec_name( _classname ).
  READ REPORT includename INTO reportlist.
  protectedsection = xmldoc-&gt;create_element( &apos;protectedSection&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = protectedsection-&gt;if_ixml_node~set_value( reportstring ).
  CLEAR reportstring.
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_prisec_name( _classname ).
  READ REPORT includename INTO reportlist.
  privatesection = xmldoc-&gt;create_element( &apos;privateSection&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = privatesection-&gt;if_ixml_node~set_value( reportstring ).
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_ccimp_name( _classname ).
  READ REPORT includename INTO reportlist.
  localimplementation = xmldoc-&gt;create_element( &apos;localImplementation&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = localimplementation-&gt;if_ixml_node~set_value( reportstring ).
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_ccdef_name( _classname ).
  READ REPORT includename INTO reportlist.
  localtypes = xmldoc-&gt;create_element( &apos;localTypes&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = localtypes-&gt;if_ixml_node~set_value( reportstring ).
*|--------------------------------------------------------------------|
  includename = cl_oo_classname_service=&gt;get_ccmac_name( _classname ).
  READ REPORT includename INTO reportlist.
  localmacros = xmldoc-&gt;create_element( &apos;localMacros&apos; ).
  reportstring = buildsourcestring( sourcetable = reportlist ).
  rc = localmacros-&gt;if_ixml_node~set_value( reportstring ).
*|--------------------------------------------------------------------|
*/***EVP - Added Logic for Local Test Classes  ----------------------*/
  DATA localtestclasses type ref to if_ixml_element.
  DATA localtestclassesExist type i.

  includename = cl_oo_classname_service=&gt;get_local_testclasses_include( _classname ).
  READ REPORT includename INTO reportlist.
  &quot; If sy-subrc = 0 the local test classes do exist
  localtestclassesExist = sy-subrc.
  if localtestclassesExist = 0.
    localtestclasses = xmldoc-&gt;create_element( &apos;localTestClasses&apos; ).
    reportstring = buildsourcestring( sourcetable = reportlist ).
    rc = localtestclasses-&gt;if_ixml_node~set_value( reportstring ).
  endif.
*/***EVP - End of Added Logic for Local Test Classes  ---------------*/
**// Rich:  Start
  textPoolNode = get_textPool( ).
  docuNode = get_documentation( ).
**// Rich:  End
*|                                                                    |
*\--------------------------------------------------------------------/
  rc = rootnode-&gt;append_child( publicsection ).
  rc = rootnode-&gt;append_child( protectedsection ).
  rc = rootnode-&gt;append_child( privatesection ).
  rc = rootnode-&gt;append_child( localimplementation ).
  rc = rootnode-&gt;append_child( localtypes ).
  rc = rootnode-&gt;append_child( localmacros ).
*/***EVP - Added Logic for Local Test Classes  -------------------*/
  if localtestclassesExist = 0.
    rc = rootnode-&gt;append_child( localtestclasses ).
  endif.
*/***EVP - End of Added Logic for Local Test Classes  ------------*/
**// Rich:  Start
  rc = rootnode-&gt;append_child( textPoolNode ).
  rc = rootnode-&gt;append_child( docuNode ).
**// Rich:  End

  CALL FUNCTION &apos;SEO_TYPEPUSAGE_READ_ALL&apos;
    EXPORTING
      cifkey      = classkey
      version     = &apos;1&apos;
    IMPORTING
      typepusages = forwarddeclarationlist.
*comment rrq old way....forwardDeclarations the only attribute
*set was the &quot;TypeGroup&quot;
*the new way....the entire structure is passed as in node typeUsage
  LOOP AT forwarddeclarationlist INTO forwarddeclarationrow.
    forwarddeclaration = xmldoc-&gt;create_element( &apos;typeUsage&apos; ).
    setattributesfromstructure( node = forwarddeclaration structure =
    forwarddeclarationrow ).
    rc = rootnode-&gt;append_child( forwarddeclaration ).
  ENDLOOP.

*ewH: for version 0.1.3, we will continue to generate both nodes
* in order for upgradeability of saplink itself.  For version
* 2.0, forwardDeclaration node generations will be deprecated.
  LOOP AT forwarddeclarationlist INTO forwarddeclarationrow.
    forwarddeclaration = xmldoc-&gt;create_element( &apos;forwardDeclaration&apos; ).
    tempstring = forwarddeclarationrow-typegroup.
    rc = forwarddeclaration-&gt;if_ixml_node~set_value( tempstring ).
    rc = rootnode-&gt;append_child( forwarddeclaration ).
  ENDLOOP.

*  classDescriptor ?= cl_abap_typedescr=&gt;describe_by_name( className ).
  attribkey-clsname = objname.

  LOOP AT classdescr-&gt;attributes INTO attribdescr
  WHERE is_inherited = abap_false
  and is_interface = abap_false. &quot;rrq:issue 46
    attribnode = xmldoc-&gt;create_element( &apos;attribute&apos; ).
    attribkey-cmpname = attribdescr-name.
    CALL FUNCTION &apos;SEO_ATTRIBUTE_GET&apos;
      EXPORTING
        attkey    = attribkey
      IMPORTING
        attribute = attribproperties.

*   include OTR if necessary (for exception classes)
    IF attribproperties-type = &apos;SOTR_CONC&apos; AND attribproperties-attvalue
    IS NOT INITIAL.
      _otrguid = attribproperties-attvalue+1(32).
      otrnode = createnodefromotr( _otrguid ).
      if otrnode is bound.
        rc = attribnode-&gt;append_child( otrnode ).
      endif.
    ENDIF.

*   append attribute node to parent node
    setattributesfromstructure( node = attribnode structure =
    attribproperties ).
    rc = rootnode-&gt;append_child( attribnode ).
  ENDLOOP.

*// ewH: begin of logic for interface methods &amp; inheritance redesign--&gt;
* inheritances &amp; redefinitions: old source removed-recover w/subversion
  CALL FUNCTION &apos;SEO_INHERITANC_READ&apos;
    EXPORTING
      CLSKEY             = classKey
    IMPORTING
      INHERITANCE        = inheritance
      REDEFINITIONS      = redefinitions
    EXCEPTIONS
      CLASS_NOT_EXISTING = 1
      OTHERS             = 2.

  if inheritance is not initial.
    inheritanceNode = xmldoc-&gt;create_element( &apos;inheritance&apos; ).
    setattributesfromstructure( node = inheritanceNode structure =
    inheritance ).

    loop at redefinitions into redefinition.
      redefNode = xmldoc-&gt;create_element( &apos;redefinition&apos; ).
      setattributesfromstructure( node = redefNode structure =
      redefinition ).
      rc = inheritanceNode-&gt;append_child( redefNode ).
    endloop.
    rc = rootnode-&gt;append_child( inheritanceNode ).
  endif.

* methods
  LOOP AT classdescr-&gt;methods INTO methoddescr where
  not ( is_inherited = &apos;X&apos; and is_redefined is initial ).
    methodkey-clsname = _classname.
    methodkey-cpdname = methoddescr-name.
*   interface methods
    if methoddescr-is_interface = &apos;X&apos;.
      CALL METHOD cl_oo_classname_service=&gt;get_method_include
        EXPORTING
          mtdkey              = methodkey
        RECEIVING
          result              = includename
        EXCEPTIONS
          method_not_existing = 1.
      IF sy-subrc = 0.
        methodnode = xmldoc-&gt;create_element( &apos;interfaceMethod&apos; ).
        setattributesfromstructure( node = methodnode structure =
        methodkey ).
        sourcenode = xmldoc-&gt;create_element( &apos;source&apos; ).
*        tempString = includeName.
*        rc = sourceNode-&gt;set_attribute(
*          name = &apos;includeName&apos; value = tempString ).
        READ REPORT includename INTO reportlist.
        reportstring = buildsourcestring( sourcetable = reportlist ).
        rc = sourcenode-&gt;if_ixml_node~set_value( reportstring ).
        rc = methodnode-&gt;append_child( sourcenode ).
        rc = rootnode-&gt;append_child( methodnode ).
      ENDIF.
*   other methods
    else.
      clsmethkey-clsname = _classname.
      clsmethkey-cmpname = methoddescr-name.
      CLEAR methodproperties.

      if methoddescr-is_redefined = &apos;X&apos;.
        methodnode = xmldoc-&gt;create_element( &apos;method&apos; ).
        move-corresponding clsMethKey to methodProperties.
*// ewh: begin of forward compatibility hack, can be removed for next
*//      major release--&gt;
        read table redefinitions into redefinition
          with key mtdname = methoddescr-name.
        if sy-subrc = 0.
          methodProperties-clsname = redefinition-refclsname.
        endif.
*//&lt;--ewH: end of forward compatibility hack
        setattributesfromstructure( node = methodnode structure =
        methodproperties ).
      else.
        CALL FUNCTION &apos;SEO_METHOD_GET&apos;
          EXPORTING
            mtdkey       = clsmethkey
          IMPORTING
            method       = methodproperties
          EXCEPTIONS
            not_existing = 1.
        IF sy-subrc = 0.
          methodnode = xmldoc-&gt;create_element( &apos;method&apos; ).
          setattributesfromstructure( node = methodnode structure =
          methodproperties ).

*         parameters
          LOOP AT methoddescr-parameters INTO paramdescr.
            CLEAR paramproperties.
            parameternode = xmldoc-&gt;create_element( &apos;parameter&apos; ).
            paramkey-cmpname = clsmethkey-cmpname.
            paramkey-sconame = paramdescr-name.
            paramkey-clsname = objname.
            CALL FUNCTION &apos;SEO_PARAMETER_GET&apos;
              EXPORTING
                parkey    = paramkey
                version   = &apos;1&apos;
              IMPORTING
                parameter = paramproperties.
            setattributesfromstructure( node = parameternode
            structure = paramproperties ).
            rc = methodnode-&gt;append_child( parameternode ).
          ENDLOOP.

*         exceptions
          CALL FUNCTION &apos;SEO_METHOD_SIGNATURE_GET&apos;
            EXPORTING
              mtdkey  = clsmethkey
              version = &apos;1&apos;
            IMPORTING
              exceps  = exceptionlist.
          LOOP AT exceptionlist INTO anexception.
            exceptionnode = xmldoc-&gt;create_element( &apos;exception&apos; ).
            setattributesfromstructure( node = exceptionnode
            structure = anexception ).
            rc = methodnode-&gt;append_child( exceptionnode ).
          ENDLOOP.
        endif. &quot;method found
      endif. &quot;is_redefined?
*     source
      CALL METHOD cl_oo_classname_service=&gt;get_method_include
        EXPORTING
          mtdkey              = methodkey
        RECEIVING
          result              = includename
        EXCEPTIONS
          method_not_existing = 1.
      IF sy-subrc = 0.
        READ REPORT includename INTO reportlist.
        reportstring = buildsourcestring( sourcetable = reportlist ).
        sourcenode = xmldoc-&gt;create_element( &apos;source&apos; ).
        rc = sourcenode-&gt;if_ixml_node~set_value( reportstring ).
        rc = methodnode-&gt;append_child( sourcenode ).
      endif.
** StartInsert Rich - Handle method documenation
      methodDocuNode = get_method_documentation(  methodkey ).
      rc = methodnode-&gt;append_child( methodDocuNode ).
** EndInsert Rich - Handle method documenation
      rc = rootnode-&gt;append_child( methodnode ).
    endif. &quot;is_interface?
  endloop.

* append root node to xmldoc
  rc = xmldoc-&gt;append_child( rootnode ).
  ixmldocument = xmldoc.
*// &lt;--ewH: end of logic for interface methods &amp; inheritance redesign
endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK" CMPNAME="CREATEOBJECTFROMIXMLDOC" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method CREATEOBJECTFROMIXMLDOC.
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

  DATA rootnode TYPE REF TO if_ixml_element.
  DATA classkey TYPE seoclskey.
  DATA filter TYPE REF TO if_ixml_node_filter.
  DATA iterator TYPE REF TO if_ixml_node_iterator.
  DATA node TYPE REF TO if_ixml_element.
  DATA otrnode TYPE REF TO if_ixml_element.
  DATA filter2 TYPE REF TO if_ixml_node_filter.
  DATA iterator2 TYPE REF TO if_ixml_node_iterator.
  DATA superclass TYPE vseoextend-clsname.
  DATA superclasskey TYPE vseoextend.
  DATA methodsourcenode TYPE REF TO if_ixml_node.
  DATA sourcenode TYPE REF TO if_ixml_node.
  DATA source TYPE string.
  DATA sourcetable TYPE TABLE OF string.
  DATA methodkey TYPE seocpdkey.
  DATA node2 TYPE REF TO if_ixml_element.
  DATA _objtype TYPE string.
  DATA aobjname TYPE e071-obj_name.
  DATA inheritancenode TYPE REF TO if_ixml_element.
  DATA redefnode TYPE REF TO if_ixml_element.
  data textNode  type ref to if_ixml_element.
  data docNode type ref to if_ixml_element.
  data methDocNode type ref to if_ixml_element.
  DATA includename TYPE program.

*data excClass type ref to ZCX_SAPLINK.

*// --&gt; begin of new data type rrq
  DATA:
*exporting dataTypes
  e_corrnr                 TYPE trkorr,
  e_devclass               TYPE devclass,
  e_version                TYPE seoversion,
  e_genflag                TYPE genflag,
  e_authority_check        TYPE seox_boolean,
  e_overwrite              TYPE seox_boolean,
*e_suppress_meth_gen      type SEOX_BOOLEAN,
*e_suppress_refac_gen     type SEOX_BOOLEAN,
  e_method_sources         TYPE seo_method_source_table,
  e_locals_def             TYPE rswsourcet,
  e_locals_imp             TYPE rswsourcet,
  e_locals_mac             TYPE rswsourcet,
*e_suppress_ind_update    type SEOX_BOOLEAN,
*importing dataTypes
  i_korrnr                 TYPE trkorr,
*changing dataTypes
  ch_class                 TYPE vseoclass,
  ch_inheritance           TYPE vseoextend,
  ch_redefinitions         TYPE seor_redefinitions_r,
  ch_implementings         TYPE seor_implementings_r,
  ch_impl_details          TYPE seo_redefinitions,
  ch_attributes            TYPE seoo_attributes_r,
  ch_methods               TYPE seoo_methods_r,
  ch_events                TYPE seoo_events_r,
  ch_types                 TYPE seoo_types_r,
  ch_type_source           TYPE seop_source,
  ch_type_source_temp      TYPE seop_source,
  ch_parameters            TYPE seos_parameters_r,
  ch_exceps                TYPE seos_exceptions_r,
  ch_aliases               TYPE seoo_aliases_r,
  ch_typeusages            TYPE seot_typepusages_r,
  ch_clsdeferreds          TYPE seot_clsdeferrds_r,
  ch_intdeferrds           TYPE seot_intdeferrds_r,
  ch_friendships           TYPE seo_friends,
**table dataTypes
*tb_classDescription      type table of seoclasstx,
*tb_component_descr       type table of seocompotx,
*tb_subcomponent_descr    type table of seosubcotx,
* work areas for the tables
  wa_attributes            TYPE seoo_attribute_r,
  wa_types                 TYPE seoo_type_r,
  wa_friends               TYPE seofriends,
  wa_implementings         TYPE seor_implementing_r,
  wa_redefinitions         TYPE seoredef,
  wa_methods               TYPE seoo_method_r,
  wa_parameters            TYPE seos_parameter_r,
  wa_exceps                TYPE seos_exception_r,
  wa_typeusages            TYPE seot_typepusage_r, &quot;forward declarations
  wa_method_sources        TYPE seo_method_source,
  wa_events                TYPE seoo_event_r.
  DATA: lines TYPE i.
*//&lt;-- end of new data types rrq

  CALL FUNCTION &apos;SEO_BUFFER_INIT&apos;.

  e_devclass = devclass.
  _objtype = getobjecttype( ).
  e_overwrite = overwrite.
  xmldoc = ixmldocument.
  rootnode = xmldoc-&gt;find_from_name( _objtype ).

  CALL METHOD getstructurefromattributes
    EXPORTING
      node      = rootnode
    CHANGING
      structure = ch_class.

  objname = classkey-clsname = ch_class-clsname.
  ch_class-version = &apos;0&apos;.
  superclass = rootnode-&gt;get_attribute( name = &apos;REFCLSNAME&apos; ).
  IF superclass IS NOT INITIAL.
* set something for inheritence
    superclasskey-clsname = classkey-clsname.
    superclasskey-refclsname = superclass.
    superclasskey-version = &apos;0&apos;.
    superclasskey-state = &apos;1&apos;.
    MOVE-CORRESPONDING superclasskey TO ch_inheritance.
    ch_inheritance-author = &apos;BCUSER&apos;.
    ch_inheritance-createdon = sy-datum.
  ENDIF.

*Add attributes to new class
  DATA otrconcept TYPE sotr_text-concept.
  filter = xmldoc-&gt;create_filter_name( &apos;attribute&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).

  WHILE node IS NOT INITIAL.
*   create OTR texts if necessary (for exception classes)
    CLEAR otrconcept.
    otrnode = node-&gt;find_from_name( &apos;sotr&apos; ).
    IF otrnode IS NOT INITIAL.
*     ewH:33--&gt;create new concept with new guid
*      me-&gt;createotrfromnode( otrnode ).
      me-&gt;createotrfromnode(
        EXPORTING node = otrnode
        IMPORTING concept = otrconcept ).
    ENDIF.
    CLEAR wa_attributes.
*   create attribute
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_attributes.
    wa_attributes-version = &apos;0&apos;.
*   ewH:issue33--&gt;6.40 and above, must create new concept
    IF otrconcept IS NOT INITIAL.
      CONCATENATE `&apos;` otrconcept `&apos;` INTO wa_attributes-attvalue.
    ENDIF.
    APPEND wa_attributes TO ch_attributes.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.

*/***TPJ - Added Logic for TYPES  -------------------*/
*  DATA: types           TYPE seoo_types_r,
*        type_properties LIKE LINE OF types.

  filter = xmldoc-&gt;create_filter_name( &apos;types&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_types.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_types.
    wa_types-version = &apos;0&apos;.
    APPEND wa_types TO ch_types.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*/***TPJ - End of Added Logic for TYPES  -------------------*/

*/***TPJ - Added Logic for Friends  -------------------*/
*  DATA: wa_friends type seofriends.

  filter = xmldoc-&gt;create_filter_name( &apos;friends&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_friends.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_friends.
    wa_friends-version = &apos;0&apos;.
    APPEND wa_friends TO ch_friendships.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*/***TPJ - End of Added Logic for Friends  -------------------*/

*// ewH: Added Logic for Implementings(interfaces)--&gt;
  filter = xmldoc-&gt;create_filter_name( &apos;implementing&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_implementings.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_implementings.
    APPEND wa_implementings TO ch_implementings.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*//&lt;--ewH: End of Added Logic for Implementings(interfaces)

*// rrq: Added Logic for events--&gt;
  filter = xmldoc-&gt;create_filter_name( &apos;events&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_events.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_events.
    APPEND wa_events TO ch_events.
    filter2 = node-&gt;create_filter_name( &apos;parameter&apos; ).
    iterator2 = node-&gt;create_iterator_filtered( filter2 ).
    node2 ?= iterator2-&gt;get_next( ).
    WHILE node2 IS NOT INITIAL.
      CLEAR wa_parameters.
      CALL METHOD getstructurefromattributes
        EXPORTING
          node      = node2
        CHANGING
          structure = wa_parameters.

      &quot;//-&gt; Mar: Added logic for parameter/interface implementation - 08/20/2008
      IF NOT wa_parameters-clsname IS INITIAL.
        APPEND wa_parameters TO ch_parameters.
      ENDIF.
      &quot;//&lt;- Mar: Added logic for parameter/interface implementation - 08/20/2008

      node2 ?= iterator2-&gt;get_next( ).
    ENDWHILE.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*//&lt;--rrq: End of Added Logic for events

*// ewH: start redesign method/inheritances--&gt;
* inheritance
  inheritancenode = rootnode-&gt;find_from_name( &apos;inheritance&apos; ).
  IF inheritancenode IS BOUND.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = inheritancenode
      CHANGING
        structure = ch_inheritance.
*   redefs
    filter = inheritancenode-&gt;create_filter_name( &apos;redefinition&apos; ).
    iterator = inheritancenode-&gt;create_iterator_filtered( filter ).
    redefnode ?= iterator-&gt;get_next( ).
    WHILE redefnode IS NOT INITIAL.
      CALL METHOD getstructurefromattributes
        EXPORTING
          node      = redefnode
        CHANGING
          structure = wa_redefinitions.
      APPEND wa_redefinitions TO ch_redefinitions.
      redefnode ?= iterator-&gt;get_next( ).
    ENDWHILE.
  ENDIF.

*Add Methods to new class
  filter = xmldoc-&gt;create_filter_name( &apos;method&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).
  WHILE node IS NOT INITIAL.
    CLEAR wa_methods.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_methods.

*   only create metadata if method is not a redefinition
    READ TABLE ch_redefinitions INTO wa_redefinitions
    WITH KEY mtdname = wa_methods-cmpname.
    IF sy-subrc = 0.
      node ?= iterator-&gt;get_next( ).
      CONTINUE.
    ENDIF.
*// ewh: begin of backward compatibility hack, can be removed for next
*//      major release--&gt;
    IF wa_methods-clsname &lt;&gt; ch_class-clsname.
      MOVE-CORRESPONDING wa_methods TO wa_redefinitions.
      wa_redefinitions-clsname = ch_class-clsname.
      wa_redefinitions-refclsname = wa_methods-clsname.
      wa_redefinitions-version = &apos;0&apos;.
      wa_redefinitions-mtdabstrct = &apos;&apos;.
      wa_redefinitions-mtdname = wa_methods-cmpname.
      APPEND wa_redefinitions TO ch_redefinitions.

      node ?= iterator-&gt;get_next( ).
      CONTINUE.
    ENDIF.
*// &lt;--ewH: break in backward compatibility hack - 2Bcontinued below

    filter2 = node-&gt;create_filter_name( &apos;parameter&apos; ).
    iterator2 = node-&gt;create_iterator_filtered( filter2 ).
    node2 ?= iterator2-&gt;get_next( ).
    WHILE node2 IS NOT INITIAL.
      CLEAR wa_parameters.
      CALL METHOD getstructurefromattributes
        EXPORTING
          node      = node2
        CHANGING
          structure = wa_parameters.

      &quot;//-&gt; Mar: Added logic for parameter/interface implementation - 08/20/2008
      IF NOT wa_parameters-clsname IS INITIAL.
        APPEND wa_parameters TO ch_parameters.
      ENDIF.
      &quot;//&lt;- Mar: Added logic for parameter/interface implementation - 08/20/2008

      node2 ?= iterator2-&gt;get_next( ).
    ENDWHILE.
    filter2 = node-&gt;create_filter_name( &apos;exception&apos; ).
    iterator2 = node-&gt;create_iterator_filtered( filter2 ).
    node2 ?= iterator2-&gt;get_next( ).
    WHILE node2 IS NOT INITIAL.
      CALL METHOD getstructurefromattributes
        EXPORTING
          node      = node2
        CHANGING
          structure = wa_exceps.
      APPEND wa_exceps TO ch_exceps.
      node2 ?= iterator2-&gt;get_next( ).
    ENDWHILE.
    APPEND wa_methods TO ch_methods.

** StartInsert Rich - Handle method documenation
    methdocnode = node-&gt;find_from_name( &apos;methodDocumentation&apos; ).
    create_method_documentation( methdocnode ).
** EndInsert Rich - Handle method documenation

    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*// &lt;--ewH: end redesign method/inheritances
*// ewh: continuation of backward compatibility hack--&gt;
*  IF ( ch_redefinitions IS NOT INITIAL OR superclass-clsname
*  IS NOT INITIAL ) and ch_inheritance is initial.
*    CALL FUNCTION &apos;SEO_INHERITANC_CREATE_F_DATA&apos;
*      EXPORTING
*        save          = &apos; &apos;
*      CHANGING
*        inheritance   = superclasskey
*        redefinitions = ch_redefinitions.
*  ENDIF.
*// &lt;--ewH: end of backward compatibility hack


  DATA classtype TYPE seoclstype.
  DATA impkeys TYPE seor_implementing_keys.
  DATA iserror TYPE boolean.

*rrq comments Forward nodes are created in an old version of the
*create XML from object.  In that node, the only attribute set
*is the &quot;TypeGroup&quot;.  All other attributes are hard coded on the
*create Object from XML .  To fix this and make it transparent to
*users, &quot;forwaredDeclaration&quot; nodes will be supported, and a new
*node will be added.
*if it is an old version XML document, forwardDeclarations nodes
*if it is a new version XML document, typeUsages nodes

*ewH: for version 0.1.3, we will continue to generate both nodes
* in order for upgradeability of saplink itself.  For version
* 2.0, forwardDeclaration node generations will be deprecated.
  filter = xmldoc-&gt;create_filter_name( &apos;typeUsage&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).

  WHILE node IS NOT INITIAL.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_typeusages.
    APPEND wa_typeusages TO ch_typeusages.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.

* only check forwardDeclaration if typeUsages does not exist
  IF ch_typeusages IS INITIAL.
    filter = xmldoc-&gt;create_filter_name( &apos;forwardDeclaration&apos; ).
    iterator = xmldoc-&gt;create_iterator_filtered( filter ).
    node ?= iterator-&gt;get_next( ).

    WHILE node IS NOT INITIAL.
      source = node-&gt;get_value( ).
      wa_typeusages-typegroup = source.
      CLEAR wa_typeusages.
      wa_typeusages-clsname = classkey-clsname.
      wa_typeusages-version = &apos;0&apos;.
      wa_typeusages-tputype = &apos;0&apos;.
      wa_typeusages-explicit =  &apos;X&apos;.
      wa_typeusages-implicit = &apos;&apos;.
      wa_typeusages-typegroup = source.
      APPEND wa_typeusages TO ch_typeusages.
      node ?= iterator-&gt;get_next( ).
    ENDWHILE.
  ENDIF.
* new way....only one of these nodes should exist
*  filter = xmldoc-&gt;create_filter_name( &apos;typeUsage&apos; ).
*  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
*  node ?= iterator-&gt;get_next( ).
*
*  WHILE node IS NOT INITIAL.
*      CALL METHOD getstructurefromattributes
*      EXPORTING
*        node      = node
*      CHANGING
*        structure = wa_typeUsages.
*    APPEND wa_typeusages TO ch_typeusages.
*    node ?= iterator-&gt;get_next( ).
*  ENDWHILE.
*Insert source code into the methods
  filter = xmldoc-&gt;create_filter_name( &apos;method&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).

  WHILE node IS NOT INITIAL.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = wa_methods.
    methodkey-clsname = objname.
    methodkey-cpdname = wa_methods-cmpname.
    aobjname = methodkey.
    methodsourcenode = node-&gt;find_from_name( &apos;source&apos; ).
    IF methodsourcenode IS NOT INITIAL.
      CLEAR wa_method_sources.
      source = methodsourcenode-&gt;get_value( ).
      sourcetable = buildtablefromstring( source ).
      LOOP AT sourcetable INTO source.
        CHECK source IS NOT INITIAL
              &quot;// Mar: -&gt; Added of logic for comments of methods 08/20/2008
              AND STRLEN( source ) GT 5.
        &quot;// Mar: &lt;- Added of logic for comments of methods 08/20/2008
        TRANSLATE source TO UPPER CASE.
        SHIFT source LEFT DELETING LEADING space.
        IF source+0(6) = &apos;METHOD&apos;.
          DELETE sourcetable INDEX sy-tabix.
          EXIT.
        ENDIF.
      ENDLOOP.
      DESCRIBE TABLE sourcetable LINES lines.
      WHILE lines &gt; 0.
        READ TABLE sourcetable INTO source INDEX lines.
        IF source CP &apos;*endmethod*&apos;.
          IF sy-subrc  = 0 AND source+0(1) &lt;&gt; &apos;*&apos;.
*          Got it and not a comment?
            DELETE sourcetable INDEX lines.
            EXIT.
          ENDIF.
        ENDIF.
        SUBTRACT 1 FROM lines.
      ENDWHILE.
      READ TABLE ch_redefinitions INTO wa_redefinitions
      WITH KEY mtdname = methodkey-cpdname.
      IF sy-subrc = 0.
        wa_method_sources-redefine = &apos;X&apos;.
      ENDIF.
      wa_method_sources-cpdname = methodkey-cpdname.
      wa_method_sources-source = sourcetable.
      APPEND wa_method_sources TO e_method_sources.
    ENDIF.
    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*
**// ewH: create interface methods--&gt;
  filter = xmldoc-&gt;create_filter_name( &apos;interfaceMethod&apos; ).
  iterator = xmldoc-&gt;create_iterator_filtered( filter ).
  node ?= iterator-&gt;get_next( ).

  WHILE node IS NOT INITIAL.
    CALL METHOD getstructurefromattributes
      EXPORTING
        node      = node
      CHANGING
        structure = methodkey.
    aobjname = methodkey.
    methodsourcenode = node-&gt;find_from_name( &apos;source&apos; ).
    IF methodsourcenode IS NOT INITIAL.
      CLEAR wa_method_sources.
      source = methodsourcenode-&gt;get_value( ).
      sourcetable = buildtablefromstring( source ).
      LOOP AT sourcetable INTO source.
        CHECK source IS NOT INITIAL
              &quot;// Mar: -&gt; Added of logic for comments of methods- 08/20/2008
              AND STRLEN( source ) GT 5.
        &quot;// Mar: &lt;- Added of logic for comments of methods - 08/20/2008
        TRANSLATE source TO UPPER CASE.
        SHIFT source LEFT DELETING LEADING space.
        IF source+0(6) = &apos;METHOD&apos;.
          DELETE sourcetable INDEX sy-tabix.
          EXIT.
        ENDIF.
      ENDLOOP.
      DESCRIBE TABLE sourcetable LINES lines.
      WHILE lines &gt; 0.
        READ TABLE sourcetable INTO source INDEX lines.
        IF source CP &apos;*endmethod*&apos;.
          IF sy-subrc  = 0 AND source+0(1) &lt;&gt; &apos;*&apos;.
*          Got it and not a comment?
            DELETE sourcetable INDEX lines.
            EXIT.
          ENDIF.
        ENDIF.
        SUBTRACT 1 FROM lines.
      ENDWHILE.
      wa_method_sources-cpdname = methodkey-cpdname.
      wa_method_sources-redefine = wa_methods-redefin.
      wa_method_sources-source = sourcetable.

      APPEND wa_method_sources TO e_method_sources.
    ENDIF.

    node ?= iterator-&gt;get_next( ).
  ENDWHILE.
*// &lt;--ewH: end create interface methods

* local implementation
  DATA _classname TYPE seoclsname.
  _classname = objname.
  sourcenode = xmldoc-&gt;find_from_name( &apos;localImplementation&apos; ).
  IF sourcenode IS NOT INITIAL.
    source = sourcenode-&gt;get_value( ).
    e_locals_imp = buildtablefromstring( source ).
  ENDIF.

* local types
  sourcenode = xmldoc-&gt;find_from_name( &apos;localTypes&apos; ).
  IF sourcenode IS NOT INITIAL.
    source = sourcenode-&gt;get_value( ).
    e_locals_def = buildtablefromstring( source ).
  ENDIF.

* local macros
  sourcenode = xmldoc-&gt;find_from_name( &apos;localMacros&apos; ).
  IF sourcenode IS NOT INITIAL.
    source = sourcenode-&gt;get_value( ).
    e_locals_mac = buildtablefromstring( source ).
  ENDIF.

*ewH-not sure how this type_source param works. type sources can come
* from private or protected sections, but there is no way to pass
* these separately into the class create FM. After debugging into
* FM-&gt;clif_save_all-&gt;generate_classpool it treats the source table
* as one, so I am not sure how to get it to differentiate between
* private and protected sections. If only one section has types
* defined, the FM call works, otherwise all hell breaks loose. To
* solve the problem for now, we will just do an insert report for
* the sections after the class creation, since that&apos;s all the FM
* does in the end anyway. Wow, this is a really long comment, but
* I dont want to have to try to remember what the hell was going
* on here later...sorry.  :)
*insert code for publicSection
*  sourcenode = xmldoc-&gt;find_from_name( &apos;publicSection&apos; )
*  IF sourcenode IS NOT INITIAL.
*    source = sourcenode-&gt;get_value( ).
*    ch_type_source = buildtablefromstring( source ).
*  ENDIF.
**insert code for pivateSection
*  sourcenode = xmldoc-&gt;find_from_name( &apos;privateSection&apos; ).
*  IF sourcenode IS NOT INITIAL.
*    source = sourcenode-&gt;get_value( ).
*    ch_type_source_temp = buildtablefromstring( source ).
*    append lines of ch_type_source_temp to ch_type_source.
*  ENDIF.
**insert code for ProtectedSection
*  sourcenode = xmldoc-&gt;find_from_name( &apos;protectedSection&apos; ).
*  IF sourcenode IS NOT INITIAL.
*    source = sourcenode-&gt;get_value( ).
*    ch_type_source_temp = buildtablefromstring( source ).
*    append lines of ch_type_source_temp to ch_type_source.
*  ENDIF.

  name = objname.

  CALL FUNCTION &apos;SEO_CLASS_CREATE_COMPLETE&apos;
   EXPORTING
     corrnr                             = e_corrnr
     devclass                           = e_devclass
     version                            = e_version
     genflag                            = e_genflag
     authority_check                    = e_authority_check
     overwrite                          = e_overwrite
*   SUPPRESS_METHOD_GENERATION         = e_suppress_meth_gen
*   SUPPRESS_REFACTORING_SUPPORT       = e_suppress_refac_gen
     method_sources                     = e_method_sources
     locals_def                         = e_locals_def
     locals_imp                         = e_locals_imp
     locals_mac                         = e_locals_mac
*   SUPPRESS_INDEX_UPDATE              = e_suppress_ind_update
   IMPORTING
     korrnr                             = i_korrnr
* TABLES
*   CLASS_DESCRIPTIONS                 = tb_classDescription
*   COMPONENT_DESCRIPTIONS             = tb_component_descr
*   SUBCOMPONENT_DESCRIPTIONS          = tb_subcomponent_descr
    CHANGING
      class                              = ch_class
     inheritance                        = ch_inheritance
     redefinitions                      = ch_redefinitions
     implementings                      = ch_implementings
     impl_details                       = ch_impl_details
     attributes                         = ch_attributes
     methods                            = ch_methods
     events                             = ch_events
     types                              = ch_types
*   TYPE_SOURCE                        = ch_type_source &quot;???
     PARAMETERS                         = ch_parameters
     exceps                             = ch_exceps
     aliases                            = ch_aliases
     typepusages                        = ch_typeusages
     clsdeferrds                        = ch_clsdeferreds
     intdeferrds                        = ch_intdeferrds
     friendships                        = ch_friendships
   EXCEPTIONS
     existing                           = 1
     is_interface                       = 2
     db_error                           = 3
     component_error                    = 4
     no_access                          = 5
     other                              = 6
     OTHERS                             = 7.
  CASE sy-subrc.
    WHEN &apos;0&apos;.
** i guess if we made it this far, we will assume success
** successful install
    WHEN &apos;1&apos;.
      RAISE EXCEPTION TYPE zcx_saplink
        EXPORTING
          textid = zcx_saplink=&gt;existing.
    WHEN OTHERS.
      RAISE EXCEPTION TYPE zcx_saplink
        EXPORTING
          textid = zcx_saplink=&gt;system_error.
  ENDCASE.

*ewH:insert pub, prot, and priv sections manually to keep any direct
* attribute/type definitions
  aobjname = classkey-clsname.
**public
  sourcenode = xmldoc-&gt;find_from_name( &apos;publicSection&apos; ).
  IF sourcenode IS NOT INITIAL.
    includename = cl_oo_classname_service=&gt;get_pubsec_name( _classname ).
    source = sourcenode-&gt;get_value( ).
    sourcetable = buildtablefromstring( source ).
    INSERT REPORT includename FROM sourcetable EXTENSION TYPE
    srext_ext_class_public STATE &apos;I&apos;.
  ENDIF.

**protected
  sourcenode = xmldoc-&gt;find_from_name( &apos;protectedSection&apos; ).
  IF sourcenode IS NOT INITIAL.
    includename = cl_oo_classname_service=&gt;get_prosec_name( _classname ).
    source = sourcenode-&gt;get_value( ).
    sourcetable = buildtablefromstring( source ).
    INSERT REPORT includename FROM sourcetable EXTENSION TYPE
    srext_ext_class_protected STATE &apos;I&apos;.
  ENDIF.

**private
  sourcenode = xmldoc-&gt;find_from_name( &apos;privateSection&apos; ).
  IF sourcenode IS NOT INITIAL.
    includename = cl_oo_classname_service=&gt;get_prisec_name( _classname ).
    source = sourcenode-&gt;get_value( ).
    sourcetable = buildtablefromstring( source ).
    INSERT REPORT includename FROM sourcetable EXTENSION TYPE
    srext_ext_class_private STATE &apos;I&apos;.
  ENDIF.
*/***EVP - Added Logic for Local Test Classes  -------------------*/
**local test classes
  sourcenode = xmldoc-&gt;find_from_name( &apos;localTestClasses&apos; ).
  IF sourcenode IS NOT INITIAL.
    data clskey type seoclskey.
    source = sourcenode-&gt;get_value( ).
    sourcetable = buildtablefromstring( source ).

    clskey-clsname = _classname.
    call function &apos;SEO_CLASS_GENERATE_LOCALS&apos;
      exporting
        clskey                 = clskey
        force                  = overwrite
        locals_testclasses     = sourcetable
      exceptions
        not_existing           = 1
        model_only             = 2
        locals_not_generated   = 3
        locals_not_initialised = 4
        others                 = 5.
    if sy-subrc &lt;&gt; 0.
    endif.
  ENDIF.
*/***EVP - End Of Added Logic for Local Test Classes  -------------------*/

**// Rich:  Start
* Create class textpool
  textnode = xmldoc-&gt;find_from_name( &apos;textPool&apos; ).
  create_textpool( textnode ).

  docnode = xmldoc-&gt;find_from_name( &apos;classDocumentation&apos; ).
  create_documentation( docnode ).
**// Rich:  End

* insert inactive sections into worklist
  CALL FUNCTION &apos;RS_INSERT_INTO_WORKING_AREA&apos;
    EXPORTING
      object            = &apos;CPUB&apos;
      obj_name          = aobjname
    EXCEPTIONS
      wrong_object_name = 1.
  IF sy-subrc &lt;&gt; 0.
  ENDIF.

  CALL FUNCTION &apos;RS_INSERT_INTO_WORKING_AREA&apos;
    EXPORTING
      object            = &apos;CPRO&apos;
      obj_name          = aobjname
    EXCEPTIONS
      wrong_object_name = 1.
  IF sy-subrc &lt;&gt; 0.
  ENDIF.

  CALL FUNCTION &apos;RS_INSERT_INTO_WORKING_AREA&apos;
    EXPORTING
      object            = &apos;CPRI&apos;
      obj_name          = aobjname
    EXCEPTIONS
      wrong_object_name = 1.
  IF sy-subrc &lt;&gt; 0.
  ENDIF.


endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK_CLASS" CMPNAME="CREATE_DOCUMENTATION" VERSION="1" LANGU="E" DESCRIPT="Create Documentation" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="CREATE_DOCUMENTATION" SCONAME="DOCNODE" VERSION="1" LANGU="E" DESCRIPT="IF_IXML_ELEMENT" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="IF_IXML_ELEMENT"/>
  <source>method CREATE_DOCUMENTATION.

  DATA txtline_node     TYPE REF TO if_ixml_element.
  DATA txtline_filter   TYPE REF TO if_ixml_node_filter.
  DATA txtline_iterator TYPE REF TO if_ixml_node_iterator.

  DATA lang_node     TYPE REF TO if_ixml_element.
  DATA lang_filter   TYPE REF TO if_ixml_node_filter.
  DATA lang_iterator TYPE REF TO if_ixml_node_iterator.

  data obj_name type DOKHL-OBJECT.
  data class_name type string.
  data language  type string.
  data obj_langu type DOKHL-LANGU.
  data lv_str type string.
  data rc type sy-subrc.

  DATA lt_lines  TYPE TABLE OF tline.
  FIELD-SYMBOLS: &lt;ls_lines&gt; LIKE LINE OF lt_lines.

  if docnode is not bound.
    return.
  endif.

  class_name = docNode-&gt;get_attribute( name = &apos;OBJECT&apos; ).
  obj_name = class_name.

* If no class name, then there was no class documenation, just return.
  if class_name is initial.
    return.
  endif.

* Get languages from XML
  FREE: lang_filter, lang_iterator, lang_node.
  lang_filter = docNode-&gt;create_filter_name( `language` ).
  lang_iterator = docNode-&gt;create_iterator_filtered( lang_filter ).
  lang_node ?= lang_iterator-&gt;get_next( ).
  WHILE lang_node IS NOT INITIAL.

    refresh lt_lines.
    language = lang_node-&gt;get_attribute( name = &apos;SPRAS&apos; ).
    obj_langu = language.

* Get TextLines from XML
    FREE: txtline_filter, txtline_iterator, txtline_node.
    txtline_filter = lang_node-&gt;create_filter_name( `textLine` ).
    txtline_iterator = lang_node-&gt;create_iterator_filtered( txtline_filter ).
    txtline_node ?= txtline_iterator-&gt;get_next( ).
    WHILE txtline_node IS NOT INITIAL.
      APPEND INITIAL LINE TO lt_lines ASSIGNING &lt;ls_lines&gt;.
      me-&gt;getstructurefromattributes(
              EXPORTING   node      = txtline_node
              CHANGING    structure = &lt;ls_lines&gt; ).
      txtline_node ?= txtline_iterator-&gt;get_next( ).
    ENDWHILE.

* Delete any documentation that may currently exist.
    CALL FUNCTION &apos;DOCU_DEL&apos;
      EXPORTING
        id       = &apos;CL&apos;
        langu    = obj_langu
        object   = obj_name
        typ      = &apos;E&apos;
      EXCEPTIONS
        ret_code = 1
        OTHERS   = 2.

* Now update with new documentation text
    CALL FUNCTION &apos;DOCU_UPD&apos;
      EXPORTING
        id       = &apos;CL&apos;
        langu    = obj_langu
        object   = obj_name
        typ      = &apos;E&apos;
      TABLES
        line     = lt_lines
      EXCEPTIONS
        ret_code = 1
        OTHERS   = 2.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_saplink
        EXPORTING
          textid = zcx_saplink=&gt;error_message
          msg    = `Class Documentation object import failed`.
    ENDIF.

    lang_node ?= lang_iterator-&gt;get_next( ).
  ENDWHILE.

endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK_CLASS" CMPNAME="CREATE_METHOD_DOCUMENTATION" VERSION="1" LANGU="E" DESCRIPT="Create Method Documentation" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="CREATE_METHOD_DOCUMENTATION" SCONAME="METHDOCNODE" VERSION="1" LANGU="E" DESCRIPT="IF_IXML_ELEMENT" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="IF_IXML_ELEMENT"/>
  <source>method CREATE_METHOD_DOCUMENTATION.

  DATA txtline_node     TYPE REF TO if_ixml_element.
  DATA txtline_filter   TYPE REF TO if_ixml_node_filter.
  DATA txtline_iterator TYPE REF TO if_ixml_node_iterator.

  DATA lang_node     TYPE REF TO if_ixml_element.
  DATA lang_filter   TYPE REF TO if_ixml_node_filter.
  DATA lang_iterator TYPE REF TO if_ixml_node_iterator.

  data obj_name type DOKHL-OBJECT.
  data classmeth_name type string.
  data language  type string.
  data obj_langu type DOKHL-LANGU.
  data lv_str type string.
  data rc type sy-subrc.

  DATA lt_lines  TYPE TABLE OF tline.
  FIELD-SYMBOLS: &lt;ls_lines&gt; LIKE LINE OF lt_lines.

  if methdocnode is not bound.
    return.
  endif.

  classmeth_name = methdocNode-&gt;get_attribute( name = &apos;OBJECT&apos; ).
  obj_name = classmeth_name.

* If no class method name, then there was no class method documenation, just return.
  if classmeth_name is initial.
    return.
  endif.

* Get languages from XML
  FREE: lang_filter, lang_iterator, lang_node.
  lang_filter = methdocNode-&gt;create_filter_name( `language` ).
  lang_iterator = methdocNode-&gt;create_iterator_filtered( lang_filter ).
  lang_node ?= lang_iterator-&gt;get_next( ).
  WHILE lang_node IS NOT INITIAL.

    refresh lt_lines.
    language = lang_node-&gt;get_attribute( name = &apos;SPRAS&apos; ).
    obj_langu = language.

* Get TextLines from XML
    FREE: txtline_filter, txtline_iterator, txtline_node.
    txtline_filter = lang_node-&gt;create_filter_name( `textLine` ).
    txtline_iterator = lang_node-&gt;create_iterator_filtered( txtline_filter ).
    txtline_node ?= txtline_iterator-&gt;get_next( ).
    WHILE txtline_node IS NOT INITIAL.
      APPEND INITIAL LINE TO lt_lines ASSIGNING &lt;ls_lines&gt;.
      me-&gt;getstructurefromattributes(
              EXPORTING   node      = txtline_node
              CHANGING    structure = &lt;ls_lines&gt; ).
      txtline_node ?= txtline_iterator-&gt;get_next( ).
    ENDWHILE.

* Delete any documentation that may currently exist.
    CALL FUNCTION &apos;DOCU_DEL&apos;
      EXPORTING
        id       = &apos;CO&apos;
        langu    = obj_langu
        object   = obj_name
        typ      = &apos;E&apos;
      EXCEPTIONS
        ret_code = 1
        OTHERS   = 2.

* Now update with new documentation text
    CALL FUNCTION &apos;DOCU_UPD&apos;
      EXPORTING
        id       = &apos;CO&apos;
        langu    = obj_langu
        object   = obj_name
        typ      = &apos;E&apos;
      TABLES
        line     = lt_lines
      EXCEPTIONS
        ret_code = 1
        OTHERS   = 2.
    IF sy-subrc &lt;&gt; 0.
      RAISE EXCEPTION TYPE zcx_saplink
        EXPORTING
          textid = zcx_saplink=&gt;error_message
          msg    = `Class Method Documentation object import failed`.
    ENDIF.

    lang_node ?= lang_iterator-&gt;get_next( ).
  ENDWHILE.

endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK_CLASS" CMPNAME="CREATE_TEXTPOOL" VERSION="1" LANGU="E" DESCRIPT="Create Class Text Pool" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="CREATE_TEXTPOOL" SCONAME="TEXTPOOLNODE" VERSION="1" LANGU="E" DESCRIPT="IF_IXML_ELEMENT" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="IF_IXML_ELEMENT"/>
  <source>method CREATE_TEXTPOOL.
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/
  data textPoolTable type standard table of textPool.
  data textPoolRow type textPool.
  data langIterator type ref to if_ixml_node_iterator.
  data filter type ref to if_ixml_node_filter.
  data textFilter type ref to if_ixml_node_filter.
  data textIterator type ref to if_ixml_node_iterator.
  data langNode type ref to if_ixml_element.
  data aTextNode type ref to if_ixml_element.
  data _objName type TROBJ_NAME.
  data obj_name type SEOCLSNAME.
  data lang type spras.
  data langNodeExists type flag.
  data logonLanguageExists type flag.
  data _state(1) type c.
  data classpoolname type program.

  if textpoolnode is not bound.
    return.
  endif.

  obj_name = objName.
  classpoolname = cl_oo_classname_service=&gt;GET_CLASSPOOL_NAME( obj_Name ).
  _objName = classpoolname.

  filter = textPoolNode-&gt;create_filter_name( &apos;language&apos; ).
  langIterator = textPoolNode-&gt;create_iterator_filtered( filter ).
  langNode ?= langIterator-&gt;get_next( ).


  while langNode is not initial.
    langNodeExists = &apos;X&apos;.

    CALL FUNCTION &apos;RS_INSERT_INTO_WORKING_AREA&apos;
      EXPORTING
        OBJECT   = &apos;REPT&apos;
        OBJ_NAME = _objName
      EXCEPTIONS
        OTHERS   = 0.
    refresh textPoolTable.
    textIterator = langNode-&gt;create_iterator( ).
    aTextNode ?= textIterator-&gt;get_next( ).
*For some reason the 1st one is blank... not sure why.
    aTextNode ?= textIterator-&gt;get_next( ).
    while aTextNode is not initial.
      CALL METHOD GETSTRUCTUREFROMATTRIBUTES
        EXPORTING
          node      = aTextNode
        CHANGING
          structure = textPoolRow.
      append textPoolRow to textPoolTable.
      aTextNode ?= textIterator-&gt;get_next( ).
    endwhile.
    if textPoolTable is not initial.
      lang = langNode-&gt;get_attribute( &apos;SPRAS&apos; ).
      if lang = sy-langu.
        logonLanguageExists = &apos;X&apos;.
        _state = &apos;I&apos;.
      else.
*       seems that if a textpool is inserted as inactive for language
*       other than the logon language, it is lost upon activation
*       not sure inserting as active is best solution,but seems to work
        _state = &apos;A&apos;.
      endif.
    endif.
    insert textpool _objName from textPooltable language lang
    state _state.
    langNode ?= langIterator-&gt;get_next( ).
  endwhile.
endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK" CMPNAME="DELETEOBJECT" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method DELETEOBJECT.
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

data clsKey type SEOCLSKEY.

  clsKey-clsname = objname.
  CALL FUNCTION &apos;SEO_CLASS_DELETE_W_DEPS&apos;
    EXPORTING
      clskey             = clsKey
    EXCEPTIONS
     NOT_EXISTING       = 1
     IS_INTERFACE       = 2
     NOT_DELETED        = 3
     DB_ERROR           = 4
     OTHERS             = 5
            .
  if sy-subrc &lt;&gt; 0.
    case sy-subrc.
      when 1.
        raise exception type zcx_saplink
          exporting textid = zcx_saplink=&gt;not_found.
      when 2.
        raise exception type zcx_saplink
          exporting
            textid = zcx_saplink=&gt;error_message
            msg = &apos;interfaces not supported&apos;.
      when 3.
        raise exception type zcx_saplink
          exporting
            textid = zcx_saplink=&gt;error_message
            msg = &apos;class not deleted&apos;.
      when others.
        raise exception type zcx_saplink
          exporting textid = zcx_saplink=&gt;system_error.
    endcase.
  endif.
endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK_CLASS" CMPNAME="FINDIMPLEMENTINGCLASS" VERSION="1" LANGU="E" DESCRIPT="Find Implementing Class" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101125" CHANGEDBY="DEVELOPER" CHANGEDON="20101127" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="FINDIMPLEMENTINGCLASS" SCONAME="METHODNAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101125" CHANGEDBY="DEVELOPER" CHANGEDON="20101127" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="FINDIMPLEMENTINGCLASS" SCONAME="STARTCLASS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101125" CHANGEDBY="DEVELOPER" CHANGEDON="20101127" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="FINDIMPLEMENTINGCLASS" SCONAME="CLASSNAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101125" CHANGEDBY="DEVELOPER" CHANGEDON="20101127" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method FINDIMPLEMENTINGCLASS.
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

data methodKey type SEOCMPKEY.
data methodProperties type VSEOMETHOD.
data classDescr type ref to cl_abap_classdescr.
data superClass type ref to cl_abap_typeDescr.
data superClassName type string.

  if startClass is initial.
    methodKey-CLSNAME = objName.
  else.
    methodKey-clsName = startClass.
  endif.
  methodKey-CMPNAME = methodName.

  call function &apos;SEO_METHOD_GET&apos;
        exporting
          MTDKEY = methodKey
        importing
          method = methodProperties
        exceptions
          NOT_EXISTING = 1.
  if sy-subrc = 0.
    className = methodProperties-clsname.
  else.
    classDescr ?= cl_abap_classDescr=&gt;describe_by_name(
    methodKey-clsName ).
    call method classDescr-&gt;GET_SUPER_CLASS_TYPE
        receiving
         P_DESCR_REF = superClass
        exceptions
          SUPER_CLASS_NOT_FOUND = 1.
    superClassName = superClass-&gt;GET_RELATIVE_NAME( ).
    className = FINDIMPLEMENTINGCLASS( methodName = methodName
    startClass = superCLassName ).
  endif.
endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK" CMPNAME="GETOBJECTTYPE" VERSION="0" EXPOSURE="0" STATE="0" EDITORDER="0 " DISPID="0 " CREATEDON="00000000" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method GETOBJECTTYPE.
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

  objecttype = &apos;CLAS&apos;.  &quot;Class

endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK_CLASS" CMPNAME="GET_DOCUMENTATION" VERSION="1" LANGU="E" DESCRIPT="Get Documentation" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="GET_DOCUMENTATION" SCONAME="DOCNODE" VERSION="1" LANGU="E" DESCRIPT="Documentation Node" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="IF_IXML_ELEMENT"/>
  <source>method GET_DOCUMENTATION.

  data languageNode   type ref to if_ixml_element.
  DATA txtlines_node TYPE REF TO if_ixml_element.
  DATA rc            TYPE sysubrc.
  DATA _objtype      TYPE string.

  Types: BEGIN OF t_dokhl,
          id          TYPE dokhl-id,
          object      TYPE dokhl-object,
          langu       type dokhl-langu,
          typ         TYPE dokhl-typ,
          dokversion  TYPE dokhl-dokversion,
         END OF t_dokhl.

  data lt_dokhl type table of t_dokhl.
  data ls_dokhl like line of lt_dokhl.

  DATA lt_lines TYPE TABLE OF tline.
  DATA ls_lines LIKE LINE OF lt_lines.

  data lv_str type string.
  DATA _objname TYPE e071-obj_name.

  _objname = objname.

* Check against database
  SELECT  id object langu typ dokversion
        INTO corresponding fields of table lt_dokhl
           FROM dokhl
             WHERE id = &apos;CL&apos;
                AND object = _objname.

* Use only most recent version.
  sort lt_dokhl by id object langu typ ascending dokversion descending.
  delete adjacent duplicates from lt_dokhl comparing id object typ langu.

  docNode = xmlDoc-&gt;create_element( &apos;classDocumentation&apos; ).

* Make sure there is at least one record here.
  clear ls_dokhl.
  read table lt_dokhl into ls_dokhl index 1.
  if sy-subrc &lt;&gt; 0.
    return.
  endif.

* Set docNode object attribute
  lv_str = ls_dokhl-object.
  rc = docNode-&gt;set_attribute( name = &apos;OBJECT&apos; value = lv_Str ).

  Loop at lt_dokhl into ls_dokhl.

* Create language node, and set attribute
    languageNode = xmlDoc-&gt;create_element( &apos;language&apos; ).
    lv_str = ls_dokhl-langu.
    rc = languageNode-&gt;set_attribute( name = &apos;SPRAS&apos; value = lv_Str ).

* Read the documentation text
    CALL FUNCTION &apos;DOCU_READ&apos;
      EXPORTING
        id      = ls_dokhl-id
        langu   = ls_dokhl-langu
        object  = ls_dokhl-object
        typ     = ls_dokhl-typ
        version = ls_dokhl-dokversion
      TABLES
        line    = lt_lines.

* Write records to XML node
    LOOP AT lt_lines INTO ls_lines.
      txtlines_node = xmlDoc-&gt;create_element( `textLine` ).
      me-&gt;setattributesfromstructure( node = txtlines_node structure = ls_lines ).
      rc = languageNode-&gt;append_child( txtlines_node ).
    ENDLOOP.
    rc = docNode-&gt;append_child( languageNode ) .
  Endloop.

endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK_CLASS" CMPNAME="GET_METHOD_DOCUMENTATION" VERSION="1" LANGU="E" DESCRIPT="Get Method Documentation" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="GET_METHOD_DOCUMENTATION" SCONAME="METHOD_KEY" VERSION="1" LANGU="E" DESCRIPT="Method Key" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="SEOCPDKEY"/>
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="GET_METHOD_DOCUMENTATION" SCONAME="DOCNODE" VERSION="1" LANGU="E" DESCRIPT="Documentation Node" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="IF_IXML_ELEMENT"/>
  <source>method GET_METHOD_DOCUMENTATION.

  data languageNode   type ref to if_ixml_element.
  DATA txtlines_node TYPE REF TO if_ixml_element.
  DATA rc            TYPE sysubrc.
  DATA _objtype      TYPE string.

  Types: BEGIN OF t_dokhl,
          id          TYPE dokhl-id,
          object      TYPE dokhl-object,
          langu       type dokhl-langu,
          typ         TYPE dokhl-typ,
          dokversion  TYPE dokhl-dokversion,
         END OF t_dokhl.

  data lt_dokhl type table of t_dokhl.
  data ls_dokhl like line of lt_dokhl.

  DATA lt_lines TYPE TABLE OF tline.
  DATA ls_lines LIKE LINE OF lt_lines.

  data lv_str type string.
  DATA _objname TYPE e071-obj_name.

  _objname = method_key.

* Check against database
  SELECT  id object langu typ dokversion
        INTO corresponding fields of table lt_dokhl
           FROM dokhl
             WHERE id = &apos;CO&apos;
                AND object = _objname.

* Use only most recent version.
  sort lt_dokhl by id object langu typ ascending dokversion descending.
  delete adjacent duplicates from lt_dokhl comparing id object typ langu.

  docNode = xmlDoc-&gt;create_element( &apos;methodDocumentation&apos; ).

* Make sure there is at least one record here.
  clear ls_dokhl.
  read table lt_dokhl into ls_dokhl index 1.
  if sy-subrc &lt;&gt; 0.
    return.
  endif.

* Set docNode object attribute
  lv_str = ls_dokhl-object.
  rc = docNode-&gt;set_attribute( name = &apos;OBJECT&apos; value = lv_Str ).

  Loop at lt_dokhl into ls_dokhl.

* Create language node, and set attribute
    languageNode = xmlDoc-&gt;create_element( &apos;language&apos; ).
    lv_str = ls_dokhl-langu.
    rc = languageNode-&gt;set_attribute( name = &apos;SPRAS&apos; value = lv_Str ).

* Read the documentation text
    CALL FUNCTION &apos;DOCU_READ&apos;
      EXPORTING
        id      = ls_dokhl-id
        langu   = ls_dokhl-langu
        object  = ls_dokhl-object
        typ     = ls_dokhl-typ
        version = ls_dokhl-dokversion
      TABLES
        line    = lt_lines.

* Write records to XML node
    LOOP AT lt_lines INTO ls_lines.
      txtlines_node = xmlDoc-&gt;create_element( `textLine` ).
      me-&gt;setattributesfromstructure( node = txtlines_node structure = ls_lines ).
      rc = languageNode-&gt;append_child( txtlines_node ).
    ENDLOOP.
    rc = docNode-&gt;append_child( languageNode ) .
  Endloop.

endmethod.</source>
  <methodDocumentation/>
 </method>
 <method CLSNAME="ZSAPLINK_CLASS" CMPNAME="GET_TEXTPOOL" VERSION="1" LANGU="E" DESCRIPT="Get Class Text Pool" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" MTDTYPE="0" MTDDECLTYP="0" R3RELEASE="702" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZSAPLINK_CLASS" CMPNAME="GET_TEXTPOOL" SCONAME="TEXTNODE" VERSION="1" LANGU="E" DESCRIPT="IF_IXML_ELEMENT" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " AUTHOR="DEVELOPER" CREATEDON="20101127" CHANGEDON="00000000" PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="IF_IXML_ELEMENT"/>
  <source>method GET_TEXTPOOL.
*/---------------------------------------------------------------------\
*|   This file is part of SAPlink.                                     |
*|                                                                     |
*|   SAPlink is free software; you can redistribute it and/or modify   |
*|   it under the terms of the GNU General Public License as published |
*|   by the Free Software Foundation; either version 2 of the License, |
*|   or (at your option) any later version.                            |
*|                                                                     |
*|   SAPlink is distributed in the hope that it will be useful,        |
*|   but WITHOUT ANY WARRANTY; without even the implied warranty of    |
*|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     |
*|   GNU General Public License for more details.                      |
*|                                                                     |
*|   You should have received a copy of the GNU General Public License |
*|   along with SAPlink; if not, write to the                          |
*|   Free Software Foundation, Inc.,                                   |
*|   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA          |
*\---------------------------------------------------------------------/

  data aText type ref to if_ixml_element.
  data textPoolTable type standard table of TEXTPOOL.
  data textPoolRow type textPool.
  data languageList type instLang.
  data aLanguage type SPRAS.
  data _objName type SEOCLSNAME.
  data rc type i.
  data sTemp type string.
  data languageNode type ref to if_ixml_element.
  DATA classpoolname TYPE program.

  _objName = objName.

  classpoolname = cl_oo_classname_service=&gt;GET_CLASSPOOL_NAME( _objName ).

  textNode = xmlDoc-&gt;create_element( &apos;textPool&apos; ).

  CALL FUNCTION &apos;RS_TEXTLOG_GET_PARAMETERS&apos;
    CHANGING
      INSTALLED_LANGUAGES = languageList.

  loop at languageList into aLanguage.
    read textpool classpoolname into textPoolTable language aLanguage.
    if sy-subrc = 0.
      languageNode = xmlDoc-&gt;create_Element( &apos;language&apos; ).
      sTemp = aLanguage.
      rc = languageNode-&gt;set_attribute( name = &apos;SPRAS&apos; value = sTemp ).
      loop at textPoolTable into textPoolRow.
        aText = xmlDoc-&gt;create_element( &apos;textElement&apos; ).
        setAttributesFromStructure( node = aText structure =
        textPoolRow ).
        rc = languageNode-&gt;append_child( aText ).
      endloop.
      rc = textNode-&gt;append_child( languageNode ).
    endif.
  endloop.

endmethod.</source>
  <methodDocumentation/>
 </method>
</CLAS>
